#!/bin/bash

# CCPM Pre-commit Hook
# Runs automated quality checks before allowing commits

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Hook configuration
HOOK_NAME="pre-commit"
PROJECT_ROOT=$(git rev-parse --show-toplevel)
CLAUDE_DIR="$PROJECT_ROOT/.claude"

echo -e "${BLUE}🔍 Running CCPM pre-commit checks...${NC}"

# Source common functions if available
if [ -f "$CLAUDE_DIR/lib/common-functions.sh" ]; then
    source "$CLAUDE_DIR/lib/common-functions.sh"
fi

# Initialize results
checks_passed=0
checks_failed=0
warnings=0

# Function to report check results
report_check() {
    local status="$1"
    local message="$2"
    
    case "$status" in
        "pass")
            echo -e "${GREEN}✅ $message${NC}"
            ((checks_passed++))
            ;;
        "fail")
            echo -e "${RED}❌ $message${NC}"
            ((checks_failed++))
            ;;
        "warn")
            echo -e "${YELLOW}⚠️  $message${NC}"
            ((warnings++))
            ;;
        "info")
            echo -e "${BLUE}ℹ️  $message${NC}"
            ;;
    esac
}

# Get list of staged files
staged_files=$(git diff --cached --name-only)

if [ -z "$staged_files" ]; then
    report_check "info" "No staged files found"
    exit 0
fi

echo "Staged files:"
echo "$staged_files" | sed 's/^/  - /'
echo ""

# Check 1: Validate shell scripts with ShellCheck
check_shell_scripts() {
    report_check "info" "Checking shell scripts with ShellCheck..."
    
    local shell_files
    shell_files=$(echo "$staged_files" | grep -E '\.sh$' || true)
    
    if [ -z "$shell_files" ]; then
        report_check "info" "No shell scripts to check"
        return 0
    fi
    
    local shell_issues=0
    while IFS= read -r file; do
        if [ -f "$file" ]; then
            if command -v shellcheck >/dev/null 2>&1; then
                if shellcheck "$file"; then
                    report_check "pass" "ShellCheck passed for $file"
                else
                    report_check "fail" "ShellCheck failed for $file"
                    ((shell_issues++))
                fi
            else
                report_check "warn" "ShellCheck not available, skipping $file"
            fi
        fi
    done <<< "$shell_files"
    
    return $shell_issues
}

# Check 2: Validate JSON configuration files
check_json_files() {
    report_check "info" "Validating JSON configuration files..."
    
    local json_files
    json_files=$(echo "$staged_files" | grep -E '\.json$' || true)
    
    if [ -z "$json_files" ]; then
        report_check "info" "No JSON files to validate"
        return 0
    fi
    
    local json_issues=0
    while IFS= read -r file; do
        if [ -f "$file" ]; then
            if command -v jq >/dev/null 2>&1; then
                if jq empty "$file" 2>/dev/null; then
                    report_check "pass" "Valid JSON: $file"
                else
                    report_check "fail" "Invalid JSON: $file"
                    ((json_issues++))
                fi
            else
                report_check "warn" "jq not available, skipping JSON validation for $file"
            fi
        fi
    done <<< "$json_files"
    
    return $json_issues
}

# Check 3: Verify executable permissions for scripts
check_script_permissions() {
    report_check "info" "Checking script permissions..."
    
    local script_files
    script_files=$(echo "$staged_files" | grep -E '\.sh$' || true)
    
    if [ -z "$script_files" ]; then
        report_check "info" "No scripts to check permissions"
        return 0
    fi
    
    local permission_issues=0
    while IFS= read -r file; do
        if [ -f "$file" ]; then
            if [ -x "$file" ]; then
                report_check "pass" "Executable: $file"
            else
                report_check "fail" "Not executable: $file (run: chmod +x $file)"
                ((permission_issues++))
            fi
        fi
    done <<< "$script_files"
    
    return $permission_issues
}

# Check 4: Security scan for sensitive data
check_sensitive_data() {
    report_check "info" "Scanning for sensitive data..."
    
    local sensitive_patterns=(
        "password\s*="
        "secret\s*="
        "api[_-]?key\s*="
        "token\s*="
        "private[_-]?key"
    )
    
    local security_issues=0
    for pattern in "${sensitive_patterns[@]}"; do
        local matches
        matches=$(echo "$staged_files" | xargs grep -l -i -E "$pattern" 2>/dev/null || true)
        
        if [ -n "$matches" ]; then
            while IFS= read -r file; do
                # Skip test files and documentation
                if [[ "$file" != *test* ]] && [[ "$file" != *example* ]] && [[ "$file" != *README* ]]; then
                    report_check "fail" "Potential sensitive data in $file (pattern: $pattern)"
                    ((security_issues++))
                fi
            done <<< "$matches"
        fi
    done
    
    if [ $security_issues -eq 0 ]; then
        report_check "pass" "No sensitive data detected"
    fi
    
    return $security_issues
}

# Check 5: Test file coverage for new shell scripts
check_test_coverage() {
    report_check "info" "Checking test coverage for new scripts..."
    
    local new_scripts
    new_scripts=$(echo "$staged_files" | grep -E '\.claude/.*\.sh$' || true)
    
    if [ -z "$new_scripts" ]; then
        report_check "info" "No new CCPM scripts to check test coverage"
        return 0
    fi
    
    local coverage_issues=0
    while IFS= read -r script; do
        local script_name
        script_name=$(basename "$script" .sh)
        
        # Look for corresponding test file
        local test_file
        test_file=$(find tests -name "*${script_name}*" -name "*.bats" 2>/dev/null | head -1)
        
        if [ -n "$test_file" ]; then
            report_check "pass" "Test coverage found for $script: $test_file"
        else
            report_check "warn" "No test coverage found for $script"
            ((coverage_issues++))
        fi
    done <<< "$new_scripts"
    
    return 0  # Don't fail commit for missing tests, just warn
}

# Check 6: CCPM project structure validation
check_project_structure() {
    report_check "info" "Validating CCPM project structure..."
    
    local structure_issues=0
    
    # Check for critical directories
    local required_dirs=(
        ".claude"
        ".claude/config" 
        ".claude/lib"
        "tests"
    )
    
    for dir in "${required_dirs[@]}"; do
        if [ ! -d "$dir" ]; then
            report_check "fail" "Missing required directory: $dir"
            ((structure_issues++))
        fi
    done
    
    # Check for critical files
    local critical_files=(
        ".claude/CLAUDE.md"
        ".claude/lib/common-functions.sh"
    )
    
    for file in "${critical_files[@]}"; do
        if [ ! -f "$file" ]; then
            report_check "warn" "Missing recommended file: $file"
        fi
    done
    
    if [ $structure_issues -eq 0 ]; then
        report_check "pass" "Project structure is valid"
    fi
    
    return $structure_issues
}

# Run all checks
echo -e "${BLUE}Running quality checks...${NC}"
echo ""

check_shell_scripts || true
echo ""

check_json_files || true
echo ""

check_script_permissions || true
echo ""

check_sensitive_data || true
echo ""

check_test_coverage || true
echo ""

check_project_structure || true
echo ""

# Summary
echo -e "${BLUE}📊 Pre-commit Check Summary${NC}"
echo "Checks passed: $checks_passed"
echo "Checks failed: $checks_failed"
echo "Warnings: $warnings"

if [ $checks_failed -gt 0 ]; then
    echo ""
    echo -e "${RED}💥 Pre-commit checks failed!${NC}"
    echo "Please fix the issues above before committing."
    echo ""
    echo "To bypass these checks (not recommended):"
    echo "  git commit --no-verify"
    echo ""
    exit 1
else
    echo ""
    if [ $warnings -gt 0 ]; then
        echo -e "${YELLOW}⚠️  Commit allowed with warnings${NC}"
        echo "Consider addressing the warnings above."
    else
        echo -e "${GREEN}✅ All pre-commit checks passed!${NC}"
    fi
    echo ""
    exit 0
fi