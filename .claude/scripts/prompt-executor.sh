#!/bin/bash

# CCPM Prompt Executor v2.0
# Execute complex prompts with file reference validation and template management

set -euo pipefail

# Load core functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$(dirname "$SCRIPT_DIR")/lib"

# Load libraries with error checking
if [[ -f "$LIB_DIR/core.sh" ]]; then
    source "$LIB_DIR/core.sh"
fi

if [[ -f "$LIB_DIR/ui.sh" ]]; then
    source "$LIB_DIR/ui.sh"
fi

# Configuration
PROMPTS_DIR=".claude/tmp/prompts"
TEMPLATES_DIR=".claude/templates/prompts"
SESSIONS_DIR=".claude/tmp/prompt-sessions"

# Function to show usage
show_usage() {
    show_command_help "prompt-executor" "Execute complex prompts with validation" \
        "prompt-executor [prompt] [options]           # Execute complex prompt
prompt-executor --template analysis            # Use saved template
prompt-executor \"prompt\" --save my-template   # Save as template
prompt-executor @file1 @file2 analyze         # Multi-file analysis"
    
    echo ""
    echo "Input Methods:"
    echo "  [prompt_text]                   Direct prompt text"
    echo "  --interactive                   Interactive prompt input"
    echo "  --template <name>               Use saved template"
    echo ""
    echo "File References:"
    echo "  @file.js                        Reference specific file"
    echo "  @src/*.js                       Glob pattern reference"
    echo "  @directory/                     Directory reference"
    echo ""
    echo "Options:"
    echo "  --save <name>                   Save prompt as template"
    echo "  --validate                      Validate file references"
    echo "  --dry-run                       Preview without execution"
    echo "  --context                       Include file context"
    echo "  --help                          Show this help message"
    echo ""
    echo "Examples:"
    echo "  prompt-executor \"Analyze @src/main.js for bugs\"           # Single file"
    echo "  prompt-executor --template code-review                    # Use template"
    echo "  prompt-executor \"Review @src/*.js\" --validate             # Glob with validation"
    echo "  prompt-executor --interactive --save analysis-template    # Interactive with save"
}

# Initialize prompt session
init_prompt_session() {
    local session_id="prompt-$(date +%Y%m%d-%H%M%S)"
    local session_dir="$SESSIONS_DIR/$session_id"
    
    ensure_directory "$session_dir"
    ensure_directory "$TEMPLATES_DIR"
    
    echo "$session_dir"
}

# Load prompt template
load_template() {
    local template_name="$1"
    local template_file="$TEMPLATES_DIR/$template_name.md"
    
    if [[ ! -f "$template_file" ]]; then
        show_error "Template Missing" "Template not found: $template_name"
        
        show_info "Available templates:"
        if ls "$TEMPLATES_DIR"/*.md >/dev/null 2>&1; then
            for template in "$TEMPLATES_DIR"/*.md; do
                local name
                name=$(basename "$template" .md)
                echo "  ‚Ä¢ $name"
            done
        else
            echo "  (No templates available)"
        fi
        return 1
    fi
    
    # Extract template metadata
    local description author created
    description=$(grep "^# " "$template_file" | head -1 | cut -c3- || echo "No description")
    author=$(grep "^Author:" "$template_file" | cut -d':' -f2- | sed 's/^ *//' || echo "Unknown")
    created=$(grep "^Created:" "$template_file" | cut -d':' -f2- | sed 's/^ *//' || echo "Unknown")
    
    show_info "Template loaded: $template_name"
    echo "  Description: $description"
    echo "  Author: $author"
    echo "  Created: $created"
    
    # Extract content (everything before metadata separator)
    local content
    if grep -q "^---$" "$template_file"; then
        content=$(sed '/^---$/,$d' "$template_file")
    else
        content=$(cat "$template_file")
    fi
    
    echo "$content"
}

# Save prompt as template
save_template() {
    local template_name="$1"
    local prompt_text="$2"
    local file_refs_count="$3"
    
    local template_file="$TEMPLATES_DIR/$template_name.md"
    local timestamp
    timestamp=$(format_timestamp)
    local author
    author=$(git config user.name 2>/dev/null || echo "CCPM User")
    
    cat > "$template_file" << EOF
# $template_name

$prompt_text

---
Author: $author
Created: $timestamp
File References: $file_refs_count
Template Version: 2.0
Generated by: CCPM Prompt Executor
EOF
    
    show_success "Template Saved" "$template_file"
    show_tip "Use with: prompt-executor --template $template_name"
}

# Extract and validate file references
process_file_references() {
    local prompt_text="$1"
    local validate_mode="$2"
    local session_dir="$3"
    
    show_subtitle "üìÅ File Reference Processing"
    
    # Extract @file references
    local file_refs
    file_refs=$(echo "$prompt_text" | grep -oE '@[^\s]+' | sed 's/^@//' || true)
    
    local valid_files=() invalid_files=() glob_patterns=()
    local refs_count=0
    
    if [[ -n "$file_refs" ]]; then
        while IFS= read -r ref; do
            [[ -z "$ref" ]] && continue
            ((refs_count++))
            
            if [[ "$ref" == *"*"* ]]; then
                # Handle glob patterns
                glob_patterns+=("$ref")
                show_info "üîç Glob pattern: @$ref"
                
                # Expand glob safely
                local expanded_files=()
                while IFS= read -r -d '' file; do
                    expanded_files+=("$file")
                done < <(find . -path "./.*" -prune -o -path "./$ref" -type f -print0 2>/dev/null || true)
                
                if [[ ${#expanded_files[@]} -gt 0 ]]; then
                    show_info "  ‚úì Matches ${#expanded_files[@]} files"
                    valid_files+=("${expanded_files[@]}")
                else
                    show_warning "No Matches" "Pattern @$ref found no files"
                    invalid_files+=("$ref")
                fi
                
            elif [[ -f "$ref" ]]; then
                show_info "‚úì Valid file: @$ref"
                valid_files+=("$ref")
                
            elif [[ -d "$ref" ]]; then
                show_info "üìÅ Directory: @$ref"
                valid_files+=("$ref")
                
            else
                show_warning "Missing File" "@$ref not found"
                invalid_files+=("$ref")
            fi
            
        done <<< "$file_refs"
    fi
    
    # Create reference report
    local refs_report="$session_dir/file-references.json"
    cat > "$refs_report" << EOF
{
  "timestamp": "$(format_timestamp)",
  "total_references": $refs_count,
  "valid_files": $(printf '%s\n' "${valid_files[@]}" | jq -R . | jq -s .),
  "invalid_files": $(printf '%s\n' "${invalid_files[@]}" | jq -R . | jq -s .),
  "glob_patterns": $(printf '%s\n' "${glob_patterns[@]}" | jq -R . | jq -s .)
}
EOF
    
    # Display summary
    show_info "üìä Reference Summary:"
    echo "  Total: $refs_count references"
    echo "  Valid: ${#valid_files[@]} files"
    echo "  Invalid: ${#invalid_files[@]} references"
    echo "  Patterns: ${#glob_patterns[@]} globs"
    
    # Validate if requested
    if [[ "$validate_mode" == true && ${#invalid_files[@]} -gt 0 ]]; then
        show_error "Validation Failed" "Found ${#invalid_files[@]} invalid file references"
        for invalid in "${invalid_files[@]}"; do
            echo "  ‚ùå @$invalid"
        done
        return 1
    fi
    
    # Return valid files array as space-separated string
    printf '%s ' "${valid_files[@]}"
}

# Add file context to prompt
add_file_context() {
    local prompt_text="$1"
    local files="$2"
    local max_files=10
    local max_lines=500
    
    if [[ -z "$files" ]]; then
        echo "$prompt_text"
        return
    fi
    
    local files_array=($files)
    local context_added=false
    local enhanced_prompt="$prompt_text"
    
    if [[ ${#files_array[@]} -gt $max_files ]]; then
        show_warning "Too Many Files" "${#files_array[@]} files found, skipping context inclusion"
        echo "$prompt_text"
        return
    fi
    
    show_info "üìñ Adding file context for ${#files_array[@]} files..."
    enhanced_prompt="$enhanced_prompt\n\n## File Context\n"
    
    for file in "${files_array[@]}"; do
        if [[ -f "$file" ]]; then
            local line_count
            line_count=$(wc -l < "$file" 2>/dev/null || echo 0)
            
            if [[ $line_count -le $max_lines ]]; then
                show_info "  üìÑ Including: $file ($line_count lines)"
                enhanced_prompt="$enhanced_prompt\n### File: $file\n\`\`\`\n$(cat "$file")\n\`\`\`\n"
                context_added=true
            else
                show_warning "Large File" "Skipping $file ($line_count lines > $max_lines)"
            fi
        elif [[ -d "$file" ]]; then
            show_info "  üìÅ Directory listing: $file"
            enhanced_prompt="$enhanced_prompt\n### Directory: $file\n\`\`\`\n$(ls -la "$file" 2>/dev/null || echo 'Cannot list directory')\n\`\`\`\n"
            context_added=true
        fi
    done
    
    if [[ "$context_added" == true ]]; then
        show_success "Context Added" "Enhanced prompt with file content"
    fi
    
    echo -e "$enhanced_prompt"
}

# Generate execution report
generate_execution_report() {
    local session_dir="$1"
    local prompt_text="$2"
    local template_name="$3"
    local save_name="$4"
    local execution_time="$5"
    
    local report_file="$session_dir/execution-report.md"
    local timestamp
    timestamp=$(format_timestamp)
    
    cat > "$report_file" << EOF
# Prompt Execution Report

**Session**: $(basename "$session_dir")  
**Generated**: $timestamp  
**Execution Time**: ${execution_time}s

## Prompt Details

**Template Used**: ${template_name:-'None'}  
**Template Saved**: ${save_name:-'None'}  
**Character Count**: $(echo "$prompt_text" | wc -c)  
**Line Count**: $(echo "$prompt_text" | wc -l)  
**Word Count**: $(echo "$prompt_text" | wc -w)

## Prompt Content

\`\`\`
$prompt_text
\`\`\`

## File References

EOF
    
    if [[ -f "$session_dir/file-references.json" ]] && command -v jq >/dev/null 2>&1; then
        local total_refs valid_count invalid_count
        total_refs=$(jq -r '.total_references' "$session_dir/file-references.json")
        valid_count=$(jq -r '.valid_files | length' "$session_dir/file-references.json")
        invalid_count=$(jq -r '.invalid_files | length' "$session_dir/file-references.json")
        
        cat >> "$report_file" << EOF
**Total References**: $total_refs  
**Valid Files**: $valid_count  
**Invalid References**: $invalid_count

### Valid Files
EOF
        
        if [[ $valid_count -gt 0 ]]; then
            jq -r '.valid_files[] | "- " + .' "$session_dir/file-references.json" >> "$report_file"
        else
            echo "None" >> "$report_file"
        fi
        
        if [[ $invalid_count -gt 0 ]]; then
            echo "" >> "$report_file"
            echo "### Invalid References" >> "$report_file"
            jq -r '.invalid_files[] | "- @" + .' "$session_dir/file-references.json" >> "$report_file"
        fi
    else
        echo "File reference analysis not available" >> "$report_file"
    fi
    
    cat >> "$report_file" << EOF

## Session Artifacts

- Execution Report: $report_file
- File References: $session_dir/file-references.json
- Raw Prompt: $session_dir/prompt.txt
EOF
    
    if [[ -n "$save_name" ]]; then
        echo "- Saved Template: $TEMPLATES_DIR/$save_name.md" >> "$report_file"
    fi
    
    cat >> "$report_file" << EOF

---
*Generated by CCPM Prompt Executor v2.0*
EOF
    
    echo "$report_file"
}

# Main execution function
main() {
    local prompt_text=""
    local template_name=""
    local save_name=""
    local validate_mode=false
    local dry_run=false
    local context_mode=false
    local interactive_mode=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --template)
                if [[ -n "${2:-}" ]]; then
                    template_name="$2"
                    shift 2
                else
                    show_error "Missing Argument" "--template requires a template name"
                    exit 1
                fi
                ;;
            --save)
                if [[ -n "${2:-}" ]]; then
                    save_name="$2"
                    shift 2
                else
                    show_error "Missing Argument" "--save requires a template name"
                    exit 1
                fi
                ;;
            --interactive)
                interactive_mode=true
                shift
                ;;
            --validate)
                validate_mode=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --context)
                context_mode=true
                shift
                ;;
            --help|-h|help)
                show_usage
                exit 0
                ;;
            -*)
                show_error "Unknown Option" "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                if [[ -z "$prompt_text" ]]; then
                    prompt_text="$1"
                else
                    prompt_text="$prompt_text $1"
                fi
                shift
                ;;
        esac
    done
    
    show_title "üìù CCPM Prompt Executor" 40
    
    # Initialize session
    local session_dir
    session_dir=$(init_prompt_session)
    show_info "Session: $(basename "$session_dir")"
    
    # Load template if specified
    if [[ -n "$template_name" ]]; then
        if ! prompt_text=$(load_template "$template_name"); then
            exit 1
        fi
    fi
    
    # Interactive input if needed
    if [[ -z "$prompt_text" || "$interactive_mode" == true ]]; then
        show_subtitle "üìù Interactive Prompt Input"
        show_info "Enter your prompt (Press Ctrl+D when finished):"
        echo ""
        
        local input_text
        input_text=$(cat)
        
        if [[ -n "$input_text" ]]; then
            if [[ -z "$prompt_text" ]]; then
                prompt_text="$input_text"
            else
                prompt_text="$prompt_text\n\n$input_text"
            fi
        fi
    fi
    
    # Validate prompt input
    if [[ -z "$prompt_text" ]]; then
        show_error "No Input" "No prompt text provided"
        show_tip "Use --interactive for interactive input or provide prompt text"
        exit 1
    fi
    
    # Save raw prompt
    echo -e "$prompt_text" > "$session_dir/prompt.txt"
    
    # Dry run mode
    if [[ "$dry_run" == true ]]; then
        show_subtitle "üîç Dry Run Preview"
        show_info "Would execute prompt:"
        echo "  Characters: $(echo "$prompt_text" | wc -c)"
        echo "  Lines: $(echo "$prompt_text" | wc -l)"
        echo "  File refs: $(echo "$prompt_text" | grep -oE '@[^\s]+' | wc -l)"
        echo "  Validation: $validate_mode"
        echo "  Context: $context_mode"
        exit 0
    fi
    
    # Process file references
    local start_time end_time execution_time
    start_time=$(date +%s)
    
    local valid_files
    valid_files=$(process_file_references "$prompt_text" "$validate_mode" "$session_dir")
    
    # Add file context if requested
    local final_prompt="$prompt_text"
    if [[ "$context_mode" == true && -n "$valid_files" ]]; then
        final_prompt=$(add_file_context "$prompt_text" "$valid_files")
    fi
    
    # Execute the prompt
    show_subtitle "‚ö° Prompt Execution"
    echo -e "$final_prompt"
    
    end_time=$(date +%s)
    execution_time=$((end_time - start_time))
    
    # Save template if requested
    if [[ -n "$save_name" ]]; then
        local ref_count
        ref_count=$(echo "$prompt_text" | grep -oE '@[^\s]+' | wc -l)
        save_template "$save_name" "$prompt_text" "$ref_count"
    fi
    
    # Generate execution report
    local report_file
    report_file=$(generate_execution_report "$session_dir" "$prompt_text" "$template_name" "$save_name" "$execution_time")
    
    # Show completion summary
    show_subtitle "‚úÖ Execution Complete"
    show_success "Prompt Executed" "Session completed successfully"
    echo "  ‚è±Ô∏è  Execution time: ${execution_time}s"
    echo "  üìÑ Report: $report_file"
    
    if [[ -n "$save_name" ]]; then
        echo "  üíæ Template saved: $save_name"
    fi
}

# Only run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi